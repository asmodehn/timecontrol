"""
A sequence of commands...
"""

# TODO
# The idea is to loop on (potentially multiple) commands,
# providing call time adjustment based on exceptions generated by the commands.

# One could control periodicity/frequency of command sequence execution...
# It is related with underlimiter and overlimiter
# Also with the looping behavior on one command...
import asyncio
import inspect
from datetime import datetime, timedelta

from timecontrol.logs.calllog import CallLog
from timecontrol.overlimiter import OverTimeLimit, OverLimiter


class ControlRunner(Mapping):
    # Note cmd can be a whole graph / category of commands ( program / code )...

    def __init__(self, cmd, args, kwargs, loop=None, timer=datetime.now, sleeper=None):
        self._cmd = cmd
        self._downtime = None  # None means infinite : the initial value

        self.plan = ControlPlan()

        # Note : instance is supposed to be in args, when decorating instance methods...
        self._args = args
        self._kwargs = kwargs

        # -> no looping, one time asap execution as usual.
        self._timer = timer
        self._sleeper = asyncio.sleep if sleeper is None else sleeper
        self._loop = asyncio.get_event_loop() if loop is None else loop

    @property
    def name(self):
        return self._cmd.__name__

    async def __call__(self):
            # TODO : maybe also integrate space representation ehre (agent id, etc.)
        """
        Triggers the controlrunner !
        :param args:
        :param kwargs:
        :return:
        """
        try:
            if asyncio.iscoroutinefunction(self._cmd):
                res = await self._cmd(*self._args, **self._kwargs)
            else:
                res = self._cmd(*self._args, **self._kwargs)
        except OverTimeLimit as otl:
            # self._cmd has been called TOO LATE !
            # => speed up !!
            print(otl)
            res = otl.result

            if self._downtime is None:
                self._downtime = timedelta(seconds=otl.expected)  # seconds by default (time is in seconds)
            else:
                self._downtime = self._downtime / 2

        if self._downtime is not None:
            # ensuring enough downtime
            if inspect.iscoroutinefunction(
                self._sleeper
            ):  # because we cannot be sure of our sleeper...
                await self._sleeper(self._downtime.total_seconds())
            else:
                self._sleeper(self._downtime.total_seconds())

            # One thing to do here : start a background loop
            asyncio.create_task(self())
            # TODO : variate the args/kwargs, based on a strategy, to generate a cache (complementary of the log...)

        return res

    # TODO : maybe manages combining commands somehow... (sequence / parallel / higher order)


class Control:
    # A decorator, that actually is a singleton : decorating multiple command is just like starting them in parallel.
    # And it is better given python semantics (one process - GIL)
    # TODO : multiprocess executor (limiting to optimal # of processes running)
    def __init__(self, timer=datetime.now, sleeper=None):
        self.timer = timer
        self.sleeper = sleeper

    def __call__(self, impl):  # decorator
        nest = self

        # starts an event loop !
        runner = ControlRunner(cmd=impl, args=(), kwargs={}, timer=self.timer, sleeper=self.sleeper)
        asyncio.run(runner())

        # def lazyrun(*args, **kwargs):
        #     # Note: we do need a function here to grab instance as the first argument.
        #     # It seems that if we use a class directly, the instance is lost when called,
        #     # replaced by the class instance being created.
        #     runner = ControlRunner(cmd=impl, args=args, kwargs=kwargs, timer=self.timer, sleeper=self.sleeper)
        #     asyncio.create_task(runner())
        #     return runner
        #
        # return lazyrun


if __name__ == "__main__":

    # # ASYNC
    # @Control()
    # async def tick():
    #     print("Running unlimited tick")
    #     print(datetime.now())
    #
    # t = tick()
    #
    # asyncio.get_event_loop().run_forever()

    # ASYNC
    @Control()
    @OverLimiter(period=3)
    async def tick():
        print("Running limited tick - period: 3")
        print(datetime.now())

    # Observe how the overlimiter timelimit influences the controller
    #Not needed without lazyrun : tick()
