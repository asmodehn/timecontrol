"""
A "group" of commands, whatever that means...

Control is eager : run commands at least once implicitely
control runs one (or more) commands once or more times.

"""

# TODO
# The idea is to loop on (potentially multiple) commands,
# providing call time adjustment based on exceptions generated by the commands.

# One could control periodicity/frequency of command sequence execution...
# It is related with underlimiter and overlimiter
# Also with the looping behavior on one command...
import asyncio
import inspect
from datetime import datetime, timedelta

from timecontrol.logs.calllog import CallLog
from timecontrol.overlimiter import OverTimeLimit, OverLimiter
from timecontrol.schedules.controlschedule import ControlSchedule, ControlIntent


class ControlRunner():  # TODO : Mapping): # with times?
    # Note cmd can be a whole graph / category of commands ( program / code )...

    def __init__(self, cmd, loop=None, timer=datetime.now, sleeper=None):
        self._cmd = cmd
        self._downtime = None  # None means infinite : the initial value

        # TODO : ControlSchedule
        self.plan = ControlSchedule(ControlIntent())  # asyncio's executor semantics ??

        # -> no looping, one time asap execution as usual.
        self._timer = timer
        self._sleeper = asyncio.sleep if sleeper is None else sleeper
        self._loop = asyncio.get_event_loop() if loop is None else loop

    @property
    def name(self):
        return self._cmd.__name__

    async def __call__(self):
        # TODO : maybe also integrate space representation here (agent id, etc.)
        """
        Triggers the controlrunner !
        :param args:
        :param kwargs:
        :return:
        """

        # TODO : extract an event from the schedule
        next_evt = self.plan()

        if next_evt:  # Falsy if there is nothing to do...

            args, kwargs = next_evt()

            # NOte : we dont use tasks just yet -> remote compute LATER
            try:
                if asyncio.iscoroutinefunction(self._cmd):
                    res = await self._cmd(*args, **kwargs)
                else:
                    res = self._cmd(*args, **kwargs)
                # TODO : finish timing now !

                assert res == next_evt.result.expected

                # be able to plugin some learning
                # TODO !!!

            except OverTimeLimit as otl:
                # self._cmd has been called TOO LATE !
                # => speed up !!
                print(otl)
                res = otl.result

                if self._downtime is None:
                    self._downtime = timedelta(seconds=otl.expected)  # seconds by default (time is in seconds)
                else:
                    self._downtime = self._downtime / 2

            if self._downtime is not None:
                # ensuring enough downtime
                if inspect.iscoroutinefunction(
                    self._sleeper
                ):  # because we cannot be sure of our sleeper...
                    await self._sleeper(self._downtime.total_seconds())
                else:
                    self._sleeper(self._downtime.total_seconds())

                # One thing to do here : start a background loop
                asyncio.create_task(self())
                # TODO : variate the args/kwargs, based on a strategy, to generate a cache (complementary of the log...)

            return res

    # TODO : maybe manages combining commands somehow... (sequence / parallel / higher order)


class Control:
    # A decorator, that actually is a singleton : decorating multiple command is just like starting them in parallel.
    # And it is better given python semantics (one process - GIL)
    # TODO : multiprocess executor (limiting to optimal # of processes running)
    def __init__(self, timer=datetime.now, sleeper=None):
        self.timer = timer
        self.sleeper = sleeper

    def __call__(self, impl):  # decorator
        nest = self

        # starts an event loop !
        runner = ControlRunner(cmd=impl, timer=self.timer, sleeper=self.sleeper)
        asyncio.run(runner())

        # def lazyrun(*args, **kwargs):
        #     # Note: we do need a function here to grab instance as the first argument.
        #     # It seems that if we use a class directly, the instance is lost when called,
        #     # replaced by the class instance being created.
        #     runner = ControlRunner(cmd=impl, args=args, kwargs=kwargs, timer=self.timer, sleeper=self.sleeper)
        #     asyncio.create_task(runner())
        #     return runner
        #
        # return lazyrun


if __name__ == "__main__":

    # ASYNC
    @Control()
    @OverLimiter(period=3)
    async def tick():
        print("Running limited tick - period: 3")
        print(datetime.now())

    # NOte : This will finish after one run (because main thread is not waiting for the loop to happen!)
